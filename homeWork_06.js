// -------------Задание 1-------------------

// KISS (Keep it simple and straightforward) - принцип говорит, что простота кода - превыше всего, потому что в простом коде проще разобраться.
// - Не подключаем всю библиотеку, если нужна всего пара функций.
// - Не создаем избыточные функции, если о них не просил заказчик.
// - Не используем избыточные классы и методы.
// - Не перегружаем интерфейс и не делаем сложную бизнесс логику.
// - Не выполняем другие действия, если они не влияют на работу проекта.

// DRY (Don’t repeat yourself) - принцип говорит, что не нужно повторят код в нашем проекте, потому что при его изменении, придется менять его везде.
// Он предлагает разделить крупную систему, на более мелкие, неповторяющиеся компоненты.

// YAGNI (You Aren’t Gonna Need It ) - принцип предполагает отказ от избыточной функциональности проекта, т.е если нет непосредственной необходимости в задаче или методе,
// то следует от них отказаться. Не стоит бояться удалять лишние методы, даже если раньше они были полезны.

// Антипаттерны чистого кода:

// - Преждевременная оптимизация - Сначала профилирование, потом оптимизация. Не меняйте простоту на эффективность, пока об этом не заявят эмпирически полученные данные.
// - Спагетти-код - Файлы случайно разбросаны по случайным каталогам. Практически невозможно понять как работает код.
// - Лодочный якорь - Предполагает, что программисты оставляют неиспользуемый код в базе, потому что он может понадобиться им позже.
// - Мертвый код - Зачастую это устаревший код написанный другим программистом. Например есть функция, которая вроде бы ничего не делает,
//   но она вызывается отовсюду и никто до конца не понимает, что она конкретно делает.
// - Разрастание кода - этот антипаттерн предполагает наличие в коде объектов, которые существуют исключительно для вызова других, более важных объектов. (Объекты-посредники)
// - Божественный объект - это объект, который делает слишком много. Например в нем содержится вся информация обо всем.
// - Магические числа - это константы используемые в коде, но которые не несут никакого смысла без соответствующего комментария.
// - Ад зависимостей - разрастание программных продуктов и библиотек, приводящее к сложности установки новых и удаления старых.

// -------------Задание 2-------------------

// Local Storage:
// - Данные хранятся в формате ключ - значение.
// - Значения хранятся в виде строк
// - Время хранения бессрочное, но при заполнении максимального объема 5 Мб, данные очищаются.
// - Данные привязаны к источнику страницы

// Session Storage:
// - Похож на Local Storage, разница заключается во времени хранения данных, а именно в случае с Session Storage данные хранятся до момента закрытия браузера.
// - Открытие страницы в новой вкладке или окне приведёт к инициированию новой сессии.
// - Данные привязаны к источнику страницы

// Cookie:
// - Небольшие фрагменты информации, которые сервер отправляет браузеру. Браузер может их сохранять и отправлять серверу, используя их при формировании запросов к нему.
// - Используются для управления сессией, персонализации и наблюдения за пользователем.
// - Существует два вида Cookie: сессионные и постоянные. Браузеры могут использовать технику восстановления сессии и восстанавливать сессионные куки, даже после закрытия браузера.

// -------------Задание 3-------------------

// <!DOCTYPE html> - указывает браузеру язык разметки, который применяется.
// <html lang="en"> - определяет естественный язык страницы.
// <head> - содержит метаданные(заголовок, скрипты, страницы стилей).
// <meta charset="UTF-8" /> - определяет кодировку символов для документа.
// <meta name="viewport" content="width=device-width, initial-scale=1.0" /> - использовать ширину экрана текущего устройства и начальный масштаб страницы(1.0 - без масштабирования).
// <title>Document</title> - заголовок страницы.
// <body></body> - тело документа в которое помещается содержимое страницы.

// БЭМ (блок, элемент, модификатор) - компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки.
// Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая "Copy Paste".

// Блок - функционально независимый компонент страницы, который может быть повторно использован. В HTML блоки представлены атрибутом class.
// - Блок не должен влиять на свое окружение, т.е блоку не следует задавать внешнюю геометрию (в виде отступов, границ, влияющих на размеры) и позиционирование.
// - В CSS по БЭМ также не рекомендуется использовать селекторы по тегам или id.

// Элемент - составная часть блока, которая не может использоваться в отрыве от него.
// - Название элемента характеризует смысл, а не состояние.
// - Структура полного имени элемента соответствует схеме: имя-блока__имя-элемента. Имя элемента отделяется от имени блока двумя подчеркиваниями.

// Модификатор - сущность, определяющая внешний вид, состояние или поведение блока либо элемента.
// - Название модификатора характеризует внешний вид, состояние и поведение. (Какой размер? Какая тема?)(Чем отличается от прочих?)(Как взаимодействует с пользователем?)
// - Имя модификатора отделяется от имено блока или элемента одним подчеркиванием.

// -------------Задание 4-------------------

// Функциональное программирование - парадигма программирования, в которой особое внимание уделяется использованию функций
// и отказу от использования данных с изменяющимся состоянием и изменяемых данных.

// Функциональная композиция - процесс объединения функций для создания более сложных функций. Результат одной функции становится параметром для другой функции.
const addThenMultiply = func(func1, func2);

// Чистая функция - это функция, которая при одинаковых параметрах возвращает один и тот же результат и не имеет побочных эффектов.
// - не изменяет внешнее состояние, например глобальные переменные.
// - Не зависит от внешнего состояния, то есть для вычисления результата она использует только свои входящие данные и локальные переменные.
const add = (a, b) => a + b;

// Неизменяемые данные - это означает, что после создания данных они не могут быть изменены.  Например const для объявления переменных или Object.freeze, чтобы сделать объект неизменяемым.
const num = 42;
num = 43; //Error

// Функции высшего порядка - функции, которые принимают другие функции в качестве входных данных или возвращают функции в качестве выходных данных.
let arr = [1, 2, 3, 4, 5];
const newArr = arr.map(() => {});

// Каррирование - техника преобразования функции с несколькими аргументами в серию функций с одним аргументом.

function curry(f) {
	return function (a) {
		return function (b) {
			return f(a, b);
		};
	};
}
function sum(a, b) {
	return a + b;
}

let curriedSum = curry(sum);
console.log(curriedSum(1)(4));

// -------------Задание 5-------------------

// Значения свойства position для позиционирования контента на странице:

// - static - значение по умолчанию, элемент позиционируется в соотвествии с его маестом в потоке документа.
// - relative - элемент позиционируется относительно своего исходного положения в потоке документа.
// - absolute - элемент позиционируется относительно ближайшего родительского элемента, который имеет позиционирование отличное от static.
// - fixed - элемент позиционируется относительно окна браузера.
// - sticky - элемент остаётся на месте при прокрутке страницы, но при этом может быть отодвинут от своей стандартной позиции.

// -------------Задание 6-------------------

// Селекторы по убыванию специфичности:

// 1. Селекторы по id (#header)
// 2. Селекторы по классу(.header), атрибуту([type='tel']) и селекторы с псевдоклассами(:hover, :focus)
// 3. Селекторы по тегу(div), селекторы с псевдоэлементами(::before, ::after)

// Комбинаторы +, >, ~, универсальный селектор * и псевдокласс :where() веса не имеют.
// Псевдоклассы :is(), :has(), :not() принимают вес наиболее специфичного селектора внутри скобок.

// CSS свойства написанные в атрибуте style внутри HTML-разметки, перебивают свойства, написанные для этого элемента во внешних CSS-файлах или внутри тега <style>.
// Ключевое слово !important нарушает все установленные спецификацией законы и насильно применяет свойство, после которого оно написано.
